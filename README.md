# unix-programming - 2023 spring
## Lab1
Solve big number mathematics and use base64 to encode the result in a shortest little endian represented number which is 8-bit aligned.
> Prepare environment for `docker` and `pwntools`

## Lab2
Implement a directory traversal program which finds a file containing a specific magic number from a target directory and its sub-directories.

` /solver /path/to/the/files/directory magic-number`

> the solver program should be compiled with the `-static` option so that it can run in a clean Linux environment

## Lab3
By modifying the PLT table and the GOT table, make the challenge server the lyrics for the song Keep the Faith. You will implement a .so file which will be preloaded to solve the challenge.

`LD_LIBRARY_PATH=. LD_PRELOAD=./libsolver.so ./chals`

## Lab4
Use `gdb`/`gef` to run and debug the challenge and read the assembly code. The goal is to guess the number generated by our challenge server.
You can use `objdump` to dump the code to debug at assembly level.

```x86_64-linux-gnu-objdump -D solver -M intel > solver.s```

## Homework 1: Secured API call
The homework aims to practice library injection, API hijacking, and GOT rewriting. You have to implement a sandbox.so by following the specification given below.
- We use a launcher program to execute a command and load your sandbox.so using LD_PRELOAD. The launcher executes the command and passes the required environment variables to an invoked process. The usage of the launcher program is as follows:

    ```Usage: ./launcher sandbox.so config.txt command arg1 arg2 ...```
- implement the sandbox.so that supports the following features:
    - Implement a ` __libc_start_main` to hijack the process‚Äôs entry point.
    - In the __libc_start_main, perform the necessary initializations and then call the real __libc_start_main.
    - To hijack an API function, you must perform GOT hijacking in the __libc_start_main of sandbox.so. 
- The functions you have to hijack:
    - open
    - read
    - connect
    - getaddrinfo
    - system
- Implement the blacklist, which will be given with the configuration file, containing blocked content for each API function.
- You can use `readelf -r` to find the GOT offset of the binary. And you can get extra point if you use `elf.h` to parse the elf information.

## Lab5
This lab aims to implement a simplified share memory mechanism as a **kernel module** that offers persistent share memories in the kernel for data exchange between user-space processes.
- The module should automatically create 8 devices in `/dev` filesystem. Each device corresponds to a kernel memory space of 4KB allocated in the kernel using the `kzalloc` function.
- The size of each shared memory file can be listed from `/proc/kshram`
- The module has to support the following `ioctl` commands, defined in` kshram.h`.
    - `KSHRAM_GETSLOTS`
    - `KSHRAM_GETSIZE`
    - `KSHRAM_SETSIZE`
- The module should support `mmap`. You can map to memory allocated in the kernel to user-space addresses so that the user-space program can access it directly.

Hints:
- Install qemu system emulator:
    ```apt install qemu-system-x86```
- Use `sh ./qemu.sh` to boot the Linux kernel in a virtual machine
- (For Apple chip) Install the compiler for x86_64 platform:

    ```apt install gcc-multilib-x86-64-linux-gnu qemu-user-static```
- (For Apple chip) Build a module inside the module source directory using:
    ```make ARCH=x86_64 CROSS_COMPILE=x86_64-linux-gnu-```

## Lab6
This lab aims to practice writing assembly codes. Your mission is to implement a sort algorithm in assembly language that sorts a given array containing ùëõ long integers in an ascending order.
- The uploaded machine code will be invoked from offset zero. It is called from the server with two arguments, the pointer to the array and the number of long integers in the array. The prototype of the function is

    ```
    typedef void (*sort_funcptr_t)(long *numbers, int n);
    ```
- upload process:
```./submit.py filename.s [scoreboard-token]```

## Lab7
This lab aims to practice writing more assembly codes. Your mission is to read FLAGs from various sources on the challenge server using the assembly language. However, before you can implement regular assembly codes, you have to bypass the constraints given by the server using return-oriented programming (ROP).
- You have to access the FLAGs using different approaches on the challenge server. The three FLAGs can be obtained by:
    - Reading it from the `/FLAG` file.
    - Attaching to a shared memory of key `0x1337` and reading the first few bytes from memory. The shared memory is filled with zeros for unused spaces.
    - Connecting to a server running at `localhost:0x1337` and receiving the data from the server.

Hints:
- call libc from python:
    ```
    import ctypes
    libc = ctypes.CDLL('libc.so.6')
    ```
- ROP (return-oriented programming): Since the stack is writable but not executable, you can write return addresses and parameter values to the stack to manipulate the program workflow to achieve your goal.