# unix-programming - 2023 spring
## Lab1
Solve big number mathematics and use base64 to encode the result in a shortest little endian represented number which is 8-bit aligned.
> Prepare environment for `docker` and `pwntools`

## Lab2
Implement a directory traversal program which finds a file containing a specific magic number from a target directory and its sub-directories.

` /solver /path/to/the/files/directory magic-number`

> the solver program should be compiled with the `-static` option so that it can run in a clean Linux environment

## Lab3
By modifying the PLT table and the GOT table, make the challenge server the lyrics for the song Keep the Faith. You will implement a .so file which will be preloaded to solve the challenge.

`LD_LIBRARY_PATH=. LD_PRELOAD=./libsolver.so ./chals`

## Lab4
Use `gdb`/`gef` to run and debug the challenge and read the assembly code. The goal is to guess the number generated by our challenge server.
You can use `objdump` to dump the code to debug at assembly level.

```x86_64-linux-gnu-objdump -D solver -M intel > solver.s```

## Homework 1: Secured API call
The homework aims to practice library injection, API hijacking, and GOT rewriting. You have to implement a sandbox.so by following the specification given below.
- We use a launcher program to execute a command and load your sandbox.so using LD_PRELOAD. The launcher executes the command and passes the required environment variables to an invoked process. The usage of the launcher program is as follows:

    ```Usage: ./launcher sandbox.so config.txt command arg1 arg2 ...```
- implement the sandbox.so that supports the following features:
    - Implement a ` __libc_start_main` to hijack the processâ€™s entry point.
    - In the __libc_start_main, perform the necessary initializations and then call the real __libc_start_main.
    - To hijack an API function, you must perform GOT hijacking in the __libc_start_main of sandbox.so. 
- The functions you have to hijack:
    - open
    - read
    - connect
    - getaddrinfo
    - system
- Implement the blacklist, which will be given with the configuration file, containing blocked content for each API function.
- You can use `readelf -r` to find the GOT offset of the binary. And you can get extra point if you use `elf.h` to parse the elf information.

## Lab5
This lab aims to implement a simplified share memory mechanism as a **kernel module** that offers persistent share memories in the kernel for data exchange between user-space processes.
- The module should automatically create 8 devices in `/dev` filesystem. Each device corresponds to a kernel memory space of 4KB allocated in the kernel using the `kzalloc` function.
- The size of each shared memory file can be listed from `/proc/kshram`
- The module has to support the following `ioctl` commands, defined in` kshram.h`.
    - `KSHRAM_GETSLOTS`
    - `KSHRAM_GETSIZE`
    - `KSHRAM_SETSIZE`
- The module should support `mmap`. You can map to memory allocated in the kernel to user-space addresses so that the user-space program can access it directly.

Hints:
- Install qemu system emulator:
    ```apt install qemu-system-x86```
- Use `sh ./qemu.sh` to boot the Linux kernel in a virtual machine
- (For Apple chip) Install the compiler for x86_64 platform:

    ```apt install gcc-multilib-x86-64-linux-gnu qemu-user-static```
- (For Apple chip) Build a module inside the module source directory using:
    ```make ARCH=x86_64 CROSS_COMPILE=x86_64-linux-gnu-```